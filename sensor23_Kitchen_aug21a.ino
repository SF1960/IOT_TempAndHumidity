#include "arduino_secrets.h"
#include "arduino_secrets.h"
/*
  Sketch to interogate the DHT11, display the results and send to Arduino IOT
  (C) Steve Fuller 2023-2025
  Version History
  Arduino now supports Home Integration which allows the temperature readingon Android
  Device randomly freezes without error message so added device restart after 100 transfers. This is now deprecated
  2025/01/28 V1 Added Preferences library to store a boot counter
  2025/01/29 V2 Added DEBUG value check to skip connecting to Serial Monitor when not connected to a PC
  2025/04/20 V3 Changed the GMT/BST date check to use last Sunday of March and October to set time
  2025/04/26 V4 Added a 24-hour restart function
  2025-05-15 V5 Rewritten sketch after Arduino AI ruined original
             Now includes more USB debug output data
             Has GMT/BST function to correctly adjust time
             Includes hourly system output and 24-hour device restart
             Added device system info fo reporting to USB monitor cloud variable
  2025-05-16 V6 Included 2 local files timeHelper.h and systemHealth.h
  2025-05-16 V7 Included a environmentHelper. h 
  2025-05-17 V7.1 Small change to ComfortStatus call and output to Comfort Level
*/

/*
  Sketch generated by the Arduino IoT Cloud Thing "Xiao Weather"
  https://create.arduino.cc/cloud/things/8b2c66c8-a852-4a0b-8370-59ef00bcc282

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  String monitor;
  String xiao_19_comfort;
  CloudCounter transfers;
  float xiao_19_depoint;
  float xiao_19_heatindex;
  float xiao_19_humidity;
  float xiao_19_temperature;
  CloudTemperatureSensor kitchen_Temp;
  CloudTemperatureSensor kitchen_Hum;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/

// ESP32C3 #23 Board

// Libraries

#include "thingProperties.h"                      // Arduino IOT library: Written by Ardiuno
#include "DHTesp.h"                               // Click here to get the library: http://librarymanager/All#DHTesp
#include <Wire.h>                                 // for connecting to the DHT11: https://reference.arduino.cc/reference/en/language/functions/communication/wire/
#include <Adafruit_GFX.h>                         // graphics library for the OLED: https://github.com/adafruit/Adafruit-GFX-Library
#include <Adafruit_SSD1306.h>                     // OLED library: https://github.com/adafruit/Adafruit_SSD1306
#include <time.h>
#include "WiFi.h"
//#include <LibPrintf.h>

// local libraries

#include "globals.h"                                // global variables, constants and declarations
#include <Preferences.h>
#include "monitorHelper.h"                          // Serial monitor local library
#include "envHelper.h"                              // ENVIII module local library
#include "oledHelper.h"                             // local library for the OLED screen
#include "timeHelper.h"                             // set up ntp and obtain time
#include "systemHealthHelper.h"                     // system health helper file
#include "environmentHelper.h"                      // the updateExtreme(), updateExtremes, checkAnomalies and getComfortStatus() functions

Preferences preferences;

/*****************************************************************************
'* Program debugging
'* Set DEBUG to 0 to disable compiling of Serial.pring statements
'****************************************************************************/

#if DEBUG == 1
  #define debug_print(x)   Serial.print(x)
  #define debug_println(x) Serial.println(x)
#else
  #define debug_print(x)
  #define debug_println(x)
#endif

// ***************************************************************************
// function to get data from DHT11
//
// Reading temperature for humidity takes about 250 milliseconds!
// Sensor readings may also be up to 2 seconds 'old' (it's a very slow sensor)
//
// ***************************************************************************

bool getTemperature() {
  
  char buffer[40];

  TempAndHumidity newValues = dht.getTempAndHumidity();

  // Update min/max temperature and humidity
  if (newValues.temperature < minTemperature) minTemperature = newValues.temperature;
  if (newValues.temperature > maxTemperature) maxTemperature = newValues.temperature;
  if (newValues.humidity < minHumidity) minHumidity = newValues.humidity;
  if (newValues.humidity > maxHumidity) maxHumidity = newValues.humidity;
  
  // Reset extremes once per day if needed
  unsigned long currentMillis = millis();
  if (currentMillis - lastExtremeReset >= EXTREMES_RESET_INTERVAL) {
    lastExtremeReset = currentMillis;
    // Don't reset to default values immediately - take current reading as new baseline
    minTemperature = maxTemperature = newValues.temperature;
    minHumidity = maxHumidity = newValues.humidity;
    Serial.println(device + "Daily reset of temperature/humidity extremes");
  }

  
  if (dht.getStatus() != 0) {                     // Check if any reads failed and exit early (to try again).

    Serial.println(device + "DHT11 error status: " + String(dht.getStatusString()));
    Serial.printf(buffer, "%s DHT11 Error Status: %s", device, String(dht.getStatusString()));
    Serial.println(buffer);

    display.clearDisplay();
    displayPrint(MEDIUM, 0, 0, "DHT11 ERROR");
    displayPrint(MEDIUM, 0, 20, String(dht.getStatusString()));

    delay(short_time);

    return false;
  }

  // call functions and return results from DHT11
  float heatindex = dht.computeHeatIndex(newValues.temperature, newValues.humidity);
  float dewpoint = dht.computeDewPoint(newValues.temperature, newValues.humidity);
  
  // Store the comfort state in a local variable first, calculate once
  ComfortState comfort_state;
  float cr = dht.getComfortRatio(cf, newValues.temperature, newValues.humidity);
  // Now use the same comfort_state value for display
  String comfortStatus = environment::getComfortStatus(comfort_state);     // get status from environmentHelper.h

  // *******************************************************
  // store results in Arduino IOT variables
  // *******************************************************
  xiao_19_temperature = newValues.temperature;
  xiao_19_humidity = newValues.humidity;
  xiao_19_comfort = comfortStatus; 

  // Google Home variables (must be on same WiFi network to work)
  kitchen_Temp = newValues.temperature;
  kitchen_Hum = newValues.humidity;

  // monitor variable
  monitor = "Readings changed - Temp: " + String(newValues.temperature) + "C : Hum: " + String(newValues.humidity) + "%RH"; 

  // Check for any significant changes in environment
  environment::checkAnomalies(newValues.temperature, newValues.humidity);
  
  return true;

} // bool getTemperature()

// *****************************************************
// * Set up function
// *****************************************************
void setup() {

  startTime = millis();

  // Initialize preferences
  preferences.begin("sensor23", false);
  unsigned int counter = preferences.getUInt("counter", 0);
  counter++; // Increment boot counter
  preferences.putUInt("counter", counter);
  preferences.end();
  
  serial::setup(115200);                                 // set up the serial monitor
  sensor::setup();                                       // start DHT11
  oled::setup();                                         // start the OLED screen

  delay(2000);
  
  display.clearDisplay();
  display.setTextSize(SMALL);
  display.setTextColor(WHITE);
  display.display();

  // set up DHT11 object
  dht.setup(dhtPin, DHTesp::DHT11);

  // Defined in thingProperties.h
  initProperties();

  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);

  /*
     The following function allows you to obtain more information
     related to the state of network and IoT Cloud connection and errors
     the higher number the more granular information you’ll get.
     The default is 0 (only errors).
     Maximum is 4
  */
  setDebugMessageLevel(0);
  ArduinoCloud.printDebugInfo();

  // Network Callbacks
  ArduinoIoTPreferredConnection.addCallback(NetworkConnectionEvent::CONNECTED, onNetworkConnect);
  ArduinoIoTPreferredConnection.addCallback(NetworkConnectionEvent::DISCONNECTED, onNetworkDisconnect);
  ArduinoIoTPreferredConnection.addCallback(NetworkConnectionEvent::ERROR, onNetworkError);

  // IOT Callbacks
  ArduinoCloud.addCallback(ArduinoIoTCloudEvent::CONNECT, doThisOnConnect);
  ArduinoCloud.addCallback(ArduinoIoTCloudEvent::SYNC, doThisOnSync);
  ArduinoCloud.addCallback(ArduinoIoTCloudEvent::DISCONNECT, doThisOnDisconnect);

  //display Welcome screen
  displayWelcome();

  // attempt IOT connection 
  int long t0 = millis();
  Serial.flush();
  Serial.print("Attempting IOT Connection.");

  do{ 
    if(millis() - t0 <= IOT_CONNECT_TIME){                 // wait for synchronisation after 30s , reboot
      ArduinoCloud.update();
    }else{
      WiFi.mode(WIFI_OFF);
      Serial.println("Rebooting...\n");
      Serial.flush();
      delay(500);
      ESP.restart();
    }
  }
  while (!flagSync);                                          // flag set to true from callback function doThisOnSync()

  //configTime(gmtOffset_sec, daylightOffset_sec, ntpServer);
  timeUtility::setup();                                       // configure and connect to ntp server
  delay (1000);                                               // wait for ntp to sync
  timeUtility::obtainTime();                                  // get time from ntp server
    
  Serial.printf(buffer,"DHT Xiao ESP32 example with tasks");
  Serial.println(buffer);

  // Update the IoT Cloud monitor variable
  monitor = "Device booted (count: " + String(counter) + ") at " + ntpTime;
  // Generate and send initial health report
  String bootReport = systemHealth::generateHealthReport();
  bootReport = "BOOT | " + bootReport + " | Boot count: " + String(counter);
  monitor = bootReport;
  ArduinoCloud.update();
  
  Serial.println("**** SET UP COMPLETE ****");

} // void setup()

// ************************************************************
// * Main Program
// *
// * Loop through Time, Temp, Humidity, Graph representations
// ************************************************************
void loop() {

  getTemperature();                // get data from DHT11 and update IOT variables
  ArduinoCloud.update();           // update the Arduino IOT
  systemHealth::checkUptimeRestart();            // restart device every 24 hours
  systemHealth::reportSystemHealth();            // System report every hour
  
  transferNumber ++;
  transfers = transferNumber;             // update Cloud Variable
  Serial.printf("SSID: %s Transfer # %i\n", SSID, transferNumber);
    
  // display WiFi connection message ONLY ONCE
  if (transfers <= 1) {

    display.clearDisplay();
    displayPrint(MEDIUM, 0, 0, "CONNECTED:");
    String ssid_text = SSID;

    // change text size dependent on SSID length
    int ssid_len = ssid_text.length();
    if (ssid_len > 10) {
      displayPrint(SMALL, 10, 30, SSID);
    } else {
      displayPrint(MEDIUM, 0, 30, SSID);
    }

    delay(long_delay);

  }

  // Temperature data is displayed from getTemperature() function
  // display all data at once
  display.clearDisplay();
  displayPrint(SMALL, 13, 5, "TEMP and HUMIDITY");
  drawHeaderLine();

  displayPrint(SMALL, 0, 21, "TEMPERATURE " + String(xiao_19_temperature) + "C");
  displayPrint(SMALL, 0, 33, "HUMIDITY    " + String(xiao_19_humidity) + "%");
  displayPrint(SMALL, 0, 45, "DEWPOINT    " + String(xiao_19_depoint) + "C");
  displayPrint(SMALL, 0, 57, "Comfort     " + String(xiao_19_comfort));

  // The main display is on for longer
  delay(long_delay);

  // display data one page at a time
  // **** TIME DISPLAY ****
  display.clearDisplay();
  displayPrint(MEDIUM, 42, 0, "TIME");
  drawHeaderLine();
  displayPrint(LARGE, 20, 26, ntpTime);     // ntpTime variable from obtainTime()
  showCopyright();

  delay(short_time);

  // display data one page at a time
  // **** TEMPERATURE DISPLAY ****
  timeUtility::obtainTime();                              // obtain the time and update IOT variable
  ArduinoCloud.update();                     // update the Arduino IOT
  display.clearDisplay();
  displayPrint(MEDIUM, 42, 0, "TEMP");
  drawHeaderLine();
  displayPrint(LARGE, 10, 26, String(xiao_19_temperature) + "C");
  showCopyright();

  delay(short_time);

  // display data one page at a time
  // **** HUMIDITY DISPLAY *****
  getTemperature();                       // get data from DHT11 and update IOT variables
  ArduinoCloud.update();                  // update the Arduino IOT
  display.clearDisplay();
  displayPrint(MEDIUM, 18, 0, "HUMIDITY");
  drawHeaderLine();
  displayPrint(LARGE, 10, 26, String(xiao_19_humidity) + "%");
  showCopyright();

  delay(short_time);

  // draw a graph for temperature and humidity
  // **** GRAPH DISPLAY ****
  display.clearDisplay();
  displayPrint(MEDIUM, 16, 0, String(xiao_19_temperature, 0) + "C");
  displayPrint(MEDIUM, 70, 0, String(xiao_19_humidity, 0) + "%");

  drawHeaderLine();

  //                                          X,   Y,   W,  H, LOW VALUE,  HIGH VAL,   INC, DIG
  DrawBarChartV(display, xiao_19_temperature, 15,  60, 25, 35, lowTempVal, highTempVal, 10, 0, "Temp", Redraw1);
  DrawBarChartV(display, xiao_19_humidity,    70,  60, 25, 35, lowHumVal,  highHumVal, 25, 0, "Hum", Redraw1);

  delay(long_delay);

  display.clearDisplay();
  
  displayPrint(MEDIUM, 16, 0, "TEMP:" + String(xiao_19_temperature, 0) + "C");
  
  //                                     X,  Y,  R,   Low,       High,      inc,  sweep,   label
  DrawDial(display, xiao_19_temperature, 65, 52, 25, lowTempVal, highTempVal, 5,   0, 200, "Temp", Redraw3);
  
  delay(long_delay);
  
  display.clearDisplay();

  displayPrint(MEDIUM, 24, 0, "HUM:" + String(xiao_19_humidity, 0) + "%");
  
  DrawDial(display, xiao_19_humidity, 65, 52, 25, lowHumVal, highHumVal, 25, 0, 200, "Hum", Redraw3);
  
  delay(long_delay);

  // display data one page at a time
  // **** COMFORT DISPLAY ****
  getTemperature();                       // get data from DHT11 and update IOT variables
  ArduinoCloud.update();                  // update the Arduino IOT
  display.clearDisplay();
  displayPrint(MEDIUM, 0, 0, "  COMFORT");
  drawHeaderLine();

  // *************************************************
  // Set the position of the comfort text (central)
  // depending on its length and set its size to fit
  // *************************************************
  display.setTextSize(LARGE);

  int txtlen = xiao_19_comfort.length();   // the text's length
  int x_posn = 0;                          // initial x position
  int y_posn = 0;                          // initial y position
  int textSize = SMALL;                    // set text size

  switch (txtlen) {
    case 2: // Ok - centered
      x_posn = 50;
      y_posn = 25;
      textSize = LARGE;
      break;
    case 7: // Too Hot
      x_posn = 10;
      y_posn = 25;
      textSize = LARGE;
      break;
    case 8: // Too Cold - centered
      x_posn = 15;
      y_posn = 30;
      textSize = MEDIUM;
      break;
    case 9: // Too Humid - centered
      x_posn = 10;
      y_posn = 30;
      textSize = MEDIUM;
      break;
    case 10: //  Cold/Humid 
      x_posn = 0;
      y_posn = 30;
      textSize = MEDIUM;
      break;
    case 11: // Hot & Humid
      x_posn = 0;
      y_posn = 30;
      textSize = MEDIUM;
      break;
    case 12: // Cold & Humid
      x_posn = 0;
      y_posn = 30;
      textSize = MEDIUM;
      break;
    default:
      x_posn = 0;
      y_posn = 30;
      textSize = SMALL;
      break;
  }; // switch(txtlen)

  displayPrint(textSize, x_posn, y_posn, xiao_19_comfort);
  showEmail();

  delay(short_time);

} // void loop()

void showCopyright() {                      // display the copyright text on last line
  displayPrint(SMALL, 35, 57, copyright);
}

void showEmail() {                          // display the email address on the last line
  displayPrint(SMALL, 17, 55, email);
}

void drawHeaderLine() {                     // display a line underneath the header
  display.drawLine(5, 16, 120, 16, WHITE);
}

// *********************************************
// * function to print to the display
// *********************************************
void displayPrint(int txtSize, int x_posn, int y_posn, String txt) {

  display.setTextSize(txtSize);
  display.setCursor(x_posn, y_posn);
  display.print(txt);
  display.display();

}

void DrawBarChartV(Adafruit_SSD1306 &d, double curval, double x, double y, double w, double h, double loval, double hival, double inc, double dig, String label, bool &Redraw)
{
  double stepval, my, level, i, data;

  if (Redraw) {
    //Redraw = false;
    //d.fillRect(0, 0,  127, 14, SSD1306_WHITE);
    //d.setTextColor(SSD1306_BLACK, SSD1306_WHITE);
    d.setTextSize(SMALL);
    //d.setCursor(x, y);
    //d.println(label);
    // step val basically scales the hival and low val to the height
    // deducting a small value to eliminate round off errors
    // this val may need to be adjusted
    stepval = ( inc) * (double (h) / (double (hival - loval))) - .001;
    for (i = 0; i <= h; i += stepval) {
      my =  y - h + i;
      d.drawFastHLine(x + w + 1, my,  5, SSD1306_WHITE);
      // draw lables
      d.setTextSize(SMALL);
      d.setTextColor(SSD1306_WHITE, SSD1306_BLACK);
      d.setCursor(x + w + 12, my - 3 );
      data = hival - ( i * (inc / stepval));
      d.print(data, dig);
    }
  }
  // compute level of bar graph that is scaled to the  height and the hi and low vals
  // this is needed to accompdate for +/- range
  level = (h * (((curval - loval) / (hival - loval))));
  // draw the bar graph
  // write a upper and lower bar to minimize flicker cause by blanking out bar and redraw on update
  d.drawRect(x, y - h, w, h, SSD1306_WHITE);
  d.fillRect(x, y - h, w, h - level,  SSD1306_BLACK);
  d.drawRect(x, y - h, w, h, SSD1306_WHITE);
  d.fillRect(x, y - level, w,  level, SSD1306_WHITE);
  // up until now print sends data to a video buffer NOT the screen
  // this call sends the data to the screen
  d.display();

}

void DrawDial(Adafruit_SSD1306 &d, double curval, int cx, int cy, int r, double loval, double hival, double inc, double dig, double sa, String label, bool &Redraw) {

  double ix, iy, ox, oy, tx, ty, lx, rx, ly, ry, i, Offset, stepval, data, angle;
  double degtorad = .0174532778;
  static double px = cx, py = cy, pix = cx, piy = cy, plx = cx, ply = cy, prx = cx, pry = cy;

  if (Redraw) {
    //Redraw = false;
    // draw the dial only one time--this will minimize flicker
    //d.fillRect(0, 0,  127, 16, SSD1306_WHITE);
    //d.setTextColor(SSD1306_BLACK, SSD1306_WHITE);
    d.setTextSize(1);
    //d.setCursor(2, 4);
    //d.println(label);
    // center the scale about the vertical axis--and use this to offset the needle, and scale text
    Offset = (270 +  sa / 2) * degtorad;
    // find hte scale step value based on the hival low val and the scale sweep angle
    // deducting a small value to eliminate round off errors
    // this val may need to be adjusted
    stepval = ( inc) * (double (sa) / (double (hival - loval))) + .00;
    // draw the scale and numbers
    // note draw this each time to repaint where the needle was
    for (i = 0; i <= sa; i += stepval) {
      angle = ( i  * degtorad);
      angle = Offset - angle ;
      ox =  (r - 2) * cos(angle) + cx;
      oy =  (r - 2) * sin(angle) + cy;
      ix =  (r - 10) * cos(angle) + cx;
      iy =  (r - 10) * sin(angle) + cy;
      tx =  (r + 10) * cos(angle) + cx + 8;
      ty =  (r + 10) * sin(angle) + cy;
      d.drawLine(ox, oy, ix, iy, SSD1306_WHITE);
      d.setTextSize(1);
      d.setTextColor(SSD1306_WHITE, SSD1306_BLACK);
      d.setCursor(tx - 10, ty );
      data = hival - ( i * (inc / stepval)) ;
      d.println(data, dig);
    }
    for (i = 0; i <= sa; i ++) {
      angle = ( i  * degtorad);
      angle = Offset - angle ;
      ox =  (r - 2) * cos(angle) + cx;
      oy =  (r - 2) * sin(angle) + cy;
      d.drawPixel(ox, oy, SSD1306_WHITE);
    }
  }
  // compute and draw the needle
  angle = (sa * (1 - (((curval - loval) / (hival - loval)))));
  angle = angle * degtorad;
  angle = Offset - angle  ;
  ix =  (r - 10) * cos(angle) + cx;
  iy =  (r - 10) * sin(angle) + cy;
  // draw a triangle for the needle (compute and store 3 vertiticies)
  lx =  2 * cos(angle - 90 * degtorad) + cx;
  ly =  2 * sin(angle - 90 * degtorad) + cy;
  rx =  2 * cos(angle + 90 * degtorad) + cx;
  ry =  2 * sin(angle + 90 * degtorad) + cy;

  // blank out the old needle
  d.fillTriangle (pix, piy, plx, ply, prx, pry, SSD1306_BLACK);

  // then draw the new needle
  d.fillTriangle (ix, iy, lx, ly, rx, ry, SSD1306_WHITE);

  // draw a cute little dial center
  d.fillCircle(cx, cy, 3, SSD1306_WHITE);

  //save all current to old so the previous dial can be hidden
  pix = ix;
  piy = iy;
  plx = lx;
  ply = ly;
  prx = rx;
  pry = ry;
  // up until now print sends data to a video buffer NOT the screen
  // this call sends the data to the screen
  d.display();

}

/**********************************************************************
* Arduino IOT and Network Callback Functoins
**********************************************************************/

// run on IOT connect
void doThisOnConnect(){
  flagConnect = true;
  Serial.println(">>>> Board successfully connected to Arduino IoT Cloud.");
  
  monitor = "CLOUD CONNECTED | Device: " + device + " | Time: " + ntpTime;
  ArduinoCloud.update();
  
  if (flagDisconnect == true) {
    flagDisconnect = false;                       // de façon à pouvoir initialiser le début de la déconnexion
    ArduinoCloud.getLocalTime();                  // Get Arduino local Time (if deconnected, updates clock with UTC Tim
    //setTimezone(TZ_INFO);
  }
}

// run on IOT disconnect
void doThisOnDisconnect(){                        // en cas de déconnexion du IoT Arduino, on reboot après x secondes
  flagConnect = false;
  if (flagDisconnect == false) {
    startDisconnect = millis();                   // start of disconnect
    flagDisconnect = true;
    Serial.print(">>>> Board disconnected from Arduino IoT Cloud  : ");
    Serial.println(startDisconnect);
    
    monitor = "CLOUD DISCONNECTED | Will attempt to reconnect";
    ArduinoCloud.update();
  }
}

// run routine when IOT reports device is synced
void doThisOnSync(){
  Serial.println(">>>> Thing Properties SYNCHRONISED.");

  monitor = "CLOUD SYNCED | Variables synchronized with cloud";
  
  ArduinoCloud.update();                          // update IoT
  delay(500);                                     // small delay to stabilise update
  flagSync = true;                                // that's ok the loop will continue to update the datas
  successfulSyncs++;
}

// run routine when IOT reports connection
void onNetworkConnect() {
  Serial.print(">>>> CONNECTED to network: ");
  Serial.println(SECRET_SSID);

  monitor = "WiFi CONNECTED | SSID: " + String(SSID) + " | IP: " +     
  WiFi.localIP().toString() + " | Signal: " + String(WiFi.RSSI()) + "dBm";
  ArduinoCloud.update();
  
}

// run routine when IOT reports dicsonnection
void onNetworkDisconnect() {
  Serial.print(">>>> DISCONNECTED from network: ");
  Serial.println(SECRET_SSID);
  
  wifiDisconnections++;
  lastWifiUptime = millis();
  
  monitor = "WiFi DISCONNECTED | Attempting reconnection...";
  ArduinoCloud.update();
  
}

// run on network error
void onNetworkError() {
  Serial.println(">>>> NETWORK ERROR !");

  if (lastWifiUptime > 0) {
    totalWifiDowntime += (millis() - lastWifiUptime);
  }
  
  monitor = "WiFi ERROR | Failed to connect to " + String(SSID);
  ArduinoCloud.update();
  
}

void displayWelcome(){

  //display Welcome screen
  display.clearDisplay();
  displayPrint(MEDIUM, 0, 0,  " *Welcome*");
  displayPrint(MEDIUM, 0, 20, "ArduinoIOT");
  displayPrint(SMALL, 0, 45, "Code by Steve Fuller");
  displayPrint(SMALL, 10, 55, "....connecting....");

}


